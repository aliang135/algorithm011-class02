#### 动态规划思维要点：

- 找到重复子问题
- 定义好状态空间
- 写状态转移方程

我们在面对一个复杂的问题的时候，首先要把大问题分解成小的问题，然后逐个解决，最后就能得到整个问题的解。当我们找到重复的子问题，有两种方式求解，一种是自顶向下，一种是自底向上。

我们前面学习的把问题转变为树形问题，然后进行深度优先或广度优先遍历，分治递归都属于自顶向下的解决问题，在用这些方法解决问题的时候，如果不进行剪枝，程序的时间复杂度就会变成恐怖的指数级。所以为了优化，我们常用一个数组存储问题的解，已经解决过的子问题就不要重复解决了，这样大大的减少了时间复杂度，这种方法叫做记忆化搜索。

动态规划跟记忆化搜索有很多相似之处，首先都要找到重复的子问题，然后要把子问题的解记录下来。他们不同之处是，一个自顶向下，一个自底向上。动态规划是自底向上的解决问题，明确了 base case 我们就可以根据它来不断的递推，最后推出答案。我们需要一种计算方式，进行递推，这种计算方式就成为状态转移方程。

#### 为什么叫动态规划？

动态规划这个中文名一开始看比较唬人，感觉高大上，看上去就很难。其实可以理解为动态递推，它是不断的滚动向前，利用前面计算出的结果推出下一个结果。

#### 什么是状态空间？

用[最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)这道题举例，这道题让我们求两个字符串 text1 和 text2 的最长公共子序列的个数，比如 text1 = "abcde", text2 = "ace" 它们的最长公共子序列是 ace 是 3。

|      | a        | b    | c    | d    | e        |
| ---- | -------- | ---- | ---- | ---- | -------- |
| a    | dp[1][1] | ...  |      |      |          |
| c    | ...      |      |      |      | ...      |
| e    |          |      |      | ...  | dp[5][3] |

为了求解这道题，我们可以定义一个二维数组,可以想象成一个表格，最上面一行是 text1,最左边一列是 text 2 中间的格子就对应这我们的状态空间。从 dp[1][1] 开始不断地递推到 dp[5][3] 就得到了我们问题的解。

那么这个二维数组就是状态空间，怎么定义这个数组的意义是很关键的一步，只有定义出它的意义，才能进一步定义状态转移方程。

在这道题中，我们定义这个二维数组的意义是，text1 和 text2 的子序列的最长公共子序列，推到最后就是这两个字符串整个的最长公共子序列。

#### 什么是状态转移方程？

上面我们定义了状态空间，每一个格子都代表了一种状态，它们都是一种中间状态，我们要根据这些中间状态推算出最后的状态，可以想象，在上面的那张表格里，状态从左上角一直转移到右下角。怎么进行转移，也就是根据我们定义的状态转移方程，一步一步的计算出一个状态保存下来，再通过这个状态转移到下一个状态。

#### 动态规划解题思路

求最值求最短路径一般都会选择用动态规划去求解，有人说万物皆可 DP ，动态规划确实给人感觉非常万能。

用动态规划解题，首先我们要找到子问题。比如在[不同路径](https://leetcode-cn.com/problems/unique-paths/)问题中，要求有多少种不同的路径，只能向右走和向下走，那么就可以转换成两个子问题，向右走一步那个的路径数加上向下走的那个路径数，这个问题可以不断地分解，直到终点。这是自顶向下的一种思路，也是比较符合人脑的思路，可以用递归求解。

也可以从终点反过来推，因为终点的位置，上面一个点和左面一个点，我们是能直接确定有多少种路径的，或者说终点上面一列和左面一行我们都能直接确定。这就是 base case 我们有这些 base case 可以直接推出最后的答案。

这就是为什么我们之前都用递归，因为一开始没有一个确定的值，我们只有推到底才能得到一个值然后一层层返回。而动态规划可以直接用 for-loop 循环，因为我们可以确定一个 base case。

所以我的解题思路是，定义好状态空间，状态转移方程，然后确定 base case 就可以直接开写 for 循环了，写循环要注意穷尽所有的状态。或者有时候，要对循环开始的定义进行修改，防止数组越界。很多时候，一开始定义的状态空间都不完美，可能定义了多维数组，可以对其进行简化。优化程序的空间复杂度。